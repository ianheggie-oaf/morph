# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `minitar` gem.
# Please instead update this file by running `bin/tapioca gem minitar`.

# source://minitar-0.12.1/lib/archive/tar/minitar.rb:4
module Archive; end

# source://minitar-0.12.1/lib/archive/tar/minitar.rb:7
module Archive::Tar
  class << self
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:13
    def const_missing(const); end

    private

    # @private
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:26
    def included(mod); end

    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:32
    def modules; end
  end
end

# == Synopsis
#
# Using minitar is easy. The simplest case is:
#
#     require 'zlib'
#     require 'minitar'
#
#     # Packs everything that matches Find.find('tests').
#     # test.tar will automatically be closed by Minitar.pack.
#     Minitar.pack('tests', File.open('test.tar', 'wb'))
#
#     # Unpacks 'test.tar' to 'x', creating 'x' if necessary.
#     Minitar.unpack('test.tar', 'x')
#
# A gzipped tar can be written with:
#
#     # test.tgz will be closed automatically.
#     Minitar.pack('tests', Zlib::GzipWriter.new(File.open('test.tgz', 'wb'))
#
#     # test.tgz will be closed automatically.
#     Minitar.unpack(Zlib::GzipReader.new(File.open('test.tgz', 'rb')), 'x')
#
# As the case above shows, one need not write to a file. However, it will
# sometimes require that one dive a little deeper into the API, as in the case
# of StringIO objects. Note that I'm not providing a block with
# Minitar::Output, as Minitar::Output#close automatically closes both the
# Output object and the wrapped data stream object.
#
#     begin
#       sgz = Zlib::GzipWriter.new(StringIO.new(""))
#       tar = Output.new(sgz)
#       Find.find('tests') do |entry|
#         Minitar.pack_file(entry, tar)
#       end
#     ensure
#         # Closes both tar and sgz.
#       tar.close
#     end
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:76
module Archive::Tar::Minitar
  class << self
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:121
    def const_missing(c); end

    # Tests if +path+ refers to a directory. Fixes an apparently
    # corrupted <tt>stat()</tt> call on Windows.
    #
    # @return [Boolean]
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:101
    def dir?(path); end

    # A convenience method for wrapping Archive::Tar::Minitar::Input.open
    # (mode +r+) and Archive::Tar::Minitar::Output.open (mode +w+). No other
    # modes are currently supported.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:110
    def open(dest, mode = T.unsafe(nil), &block); end

    # A convenience method to pack files specified by +src+ into +dest+. If
    # +src+ is an Array, then each file detailed therein will be packed into
    # the resulting Archive::Tar::Minitar::Output stream; if +recurse_dirs+ is
    # true, then directories will be recursed.
    #
    # If +src+ is not an Array, it will be treated as the result of Find.find;
    # all files matching will be packed.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:225
    def pack(src, dest, recurse_dirs = T.unsafe(nil), &block); end

    # A convenience method to pack the file provided. +entry+ may either be a
    # filename (in which case various values for the file (see below) will be
    # obtained from <tt>File#stat(entry)</tt> or a Hash with the fields:
    #
    # <tt>:name</tt>::  The filename to be packed into the archive. Required.
    # <tt>:mode</tt>::  The mode to be applied.
    # <tt>:uid</tt>::   The user owner of the file. (Ignored on Windows.)
    # <tt>:gid</tt>::   The group owner of the file. (Ignored on Windows.)
    # <tt>:mtime</tt>:: The modification Time of the file.
    #
    # During packing, if a block is provided, #pack_file yields an +action+
    # Symol, the full name of the file being packed, and a Hash of
    # statistical information, just as with
    # Archive::Tar::Minitar::Input#extract_entry.
    #
    # The +action+ will be one of:
    # <tt>:dir</tt>::           The +entry+ is a directory.
    # <tt>:file_start</tt>::    The +entry+ is a file; the extract of the
    #                           file is just beginning.
    # <tt>:file_progress</tt>:: Yielded every 4096 bytes during the extract
    #                           of the +entry+.
    # <tt>:file_done</tt>::     Yielded when the +entry+ is completed.
    #
    # The +stats+ hash contains the following keys:
    # <tt>:current</tt>:: The current total number of bytes read in the
    #                     +entry+.
    # <tt>:currinc</tt>:: The current number of bytes read in this read
    #                     cycle.
    # <tt>:name</tt>::    The filename to be packed into the tarchive.
    #                     *REQUIRED*.
    # <tt>:mode</tt>::    The mode to be applied.
    # <tt>:uid</tt>::     The user owner of the file. (+nil+ on Windows.)
    # <tt>:gid</tt>::     The group owner of the file. (+nil+ on Windows.)
    # <tt>:mtime</tt>::   The modification Time of the file.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:169
    def pack_file(entry, outputter); end

    # Check whether +io+ can seek without errors.
    #
    # @return [Boolean]
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:266
    def seekable?(io, methods = T.unsafe(nil)); end

    # A convenience method to unpack files from +src+ into the directory
    # specified by +dest+. Only those files named explicitly in +files+
    # will be extracted.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:249
    def unpack(src, dest, files = T.unsafe(nil), options = T.unsafe(nil), &block); end

    # @return [Boolean]
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:131
    def windows?; end

    private

    # @private
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:281
    def included(mod); end

    # source://minitar-0.12.1/lib/archive/tar/minitar.rb:287
    def modules; end
  end
end

# This exists to make bytesize implementations work across Ruby versions.
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:294
module Archive::Tar::Minitar::ByteSize
  private

  # source://minitar-0.12.1/lib/archive/tar/minitar.rb:298
  def bytesize(item); end
end

# The exception raised when operations are performed on a stream that has
# previously been closed.
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:85
class Archive::Tar::Minitar::ClosedStream < ::Archive::Tar::Minitar::Error; end

# The base class for any minitar error.
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:80
class Archive::Tar::Minitar::Error < ::StandardError; end

# The exception raised when a filename exceeds 256 bytes in length, the
# maximum supported by the standard Tar format.
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:88
class Archive::Tar::Minitar::FileNameTooLong < ::Archive::Tar::Minitar::Error; end

# Wraps a Archive::Tar::Minitar::Reader with convenience methods and wrapped
# stream management; Input only works with data streams that can be rewound.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:8
class Archive::Tar::Minitar::Input
  include ::Enumerable

  # Creates a new Input object. If +input+ is a stream object that responds
  # to #read, then it will simply be wrapped. Otherwise, one will be created
  # and opened using Kernel#open. When Input#close is called, the stream
  # object wrapped will be closed.
  #
  # An exception will be raised if the stream that is wrapped does not
  # support rewinding.
  #
  # call-seq:
  #    Archive::Tar::Minitar::Input.new(io) -> input
  #    Archive::Tar::Minitar::Input.new(path) -> input
  #
  # @return [Input] a new instance of Input
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:72
  def initialize(input); end

  # Closes both the Reader object and the wrapped data stream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:158
  def close; end

  # Returns false if the wrapped data stream is open.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:150
  def closed?; end

  # When provided a block, iterates through each entry in the archive. When
  # finished, rewinds to the beginning of the stream.
  #
  # If not provided a block, creates an enumerator with the same semantics.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:90
  def each; end

  # When provided a block, iterates through each entry in the archive. When
  # finished, rewinds to the beginning of the stream.
  #
  # If not provided a block, creates an enumerator with the same semantics.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:90
  def each_entry; end

  # Extracts the current +entry+ to +destdir+. If a block is provided, it
  # yields an +action+ Symbol, the full name of the file being extracted
  # (+name+), and a Hash of statistical information (+stats+).
  #
  # The +action+ will be one of:
  # <tt>:dir</tt>::           The +entry+ is a directory.
  # <tt>:file_start</tt>::    The +entry+ is a file; the extract of the
  #                           file is just beginning.
  # <tt>:file_progress</tt>:: Yielded every 4096 bytes during the extract
  #                           of the +entry+.
  # <tt>:file_done</tt>::     Yielded when the +entry+ is completed.
  #
  # The +stats+ hash contains the following keys:
  # <tt>:current</tt>:: The current total number of bytes read in the
  #                     +entry+.
  # <tt>:currinc</tt>:: The current number of bytes read in this read
  #                     cycle.
  # <tt>:entry</tt>::   The entry being extracted; this is a
  #                     Reader::EntryStream, with all methods thereof.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:120
  def extract_entry(destdir, entry, options = T.unsafe(nil), &block); end

  # Returns the Reader object for direct access.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:155
  def tar; end

  private

  # @yield [:dir, full_name, stats]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:175
  def extract_directory(destdir, full_name, entry, stats, options); end

  # @yield [:file_start, full_name, stats]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:199
  def extract_file(destdir, full_name, entry, stats, options); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:165
  def fsync_dir(dirname); end

  class << self
    # Iterates over each entry in the provided input. This wraps the common
    # pattern of:
    #
    #     Archive::Tar::Minitar::Input.open(io) do |i|
    #       inp.each do |entry|
    #         # ...
    #       end
    #     end
    #
    # If a block is not provided, an enumerator will be created with the same
    # behaviour.
    #
    # call-seq:
    #    Archive::Tar::Minitar::Input.each_entry(io) -> enumerator
    #    Archive::Tar::Minitar::Input.each_entry(io) { |entry| block } -> obj
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:51
    def each_entry(input); end

    # With no associated block, +Input.open+ is a synonym for +Input.new+. If
    # the optional code block is given, it will be given the new Input as an
    # argument and the Input object will automatically be closed when the block
    # terminates (this also closes the wrapped stream object). In this
    # instance, +Input.open+ returns the value of the block.
    #
    # call-seq:
    #    Archive::Tar::Minitar::Input.open(io) -> input
    #    Archive::Tar::Minitar::Input.open(io) { |input| block } -> obj
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/input.rb:20
    def open(input); end
  end
end

# The exception raised when a file contains an invalid Posix header.
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:96
class Archive::Tar::Minitar::InvalidTarStream < ::Archive::Tar::Minitar::Error; end

# Raised when a wrapped data stream class is not seekable.
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:82
class Archive::Tar::Minitar::NonSeekableStream < ::Archive::Tar::Minitar::Error; end

# Wraps a Archive::Tar::Minitar::Writer with convenience methods and wrapped
# stream management. If the stream provided to Output does not support random
# access, only Writer#add_file_simple and Writer#mkdir are guaranteed to
# work.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/output.rb:10
class Archive::Tar::Minitar::Output
  # Creates a new Output object. If +output+ is a stream object that responds
  # to #write, then it will simply be wrapped. Otherwise, one will be created
  # and opened using Kernel#open. When Output#close is called, the stream
  # object wrapped will be closed.
  #
  # call-seq:
  #    Archive::Tar::Minitar::Output.new(io) -> output
  #    Archive::Tar::Minitar::Output.new(path) -> output
  #
  # @return [Output] a new instance of Output
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/output.rb:56
  def initialize(output); end

  # Closes the Writer object and the wrapped data stream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/output.rb:74
  def close; end

  # Returns false if the wrapped data stream is open.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/output.rb:69
  def closed?; end

  # Returns the Writer object for direct access.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/output.rb:66
  def tar; end

  class << self
    # With no associated block, +Output.open+ is a synonym for +Output.new+. If
    # the optional code block is given, it will be given the new Output as an
    # argument and the Output object will automatically be closed when the
    # block terminates (this also closes the wrapped stream object). In this
    # instance, +Output.open+ returns the value of the block.
    #
    # call-seq:
    #    Archive::Tar::Minitar::Output.open(io) -> output
    #    Archive::Tar::Minitar::Output.open(io) { |output| block } -> obj
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/output.rb:20
    def open(output); end

    # Output.tar is a wrapper for Output.open that yields the owned tar object
    # instead of the Output object. If a block is not provided, an enumerator
    # will be created with the same behaviour.
    #
    # call-seq:
    #    Archive::Tar::Minitar::Output.tar(io) -> enumerator
    #    Archive::Tar::Minitar::Output.tar(io) { |tar| block } -> obj
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/output.rb:40
    def tar(output); end
  end
end

# Implements the POSIX tar header as a Ruby class. The structure of
# the POSIX tar header is:
#
#   struct tarfile_entry_posix
#   {                      //                               pack/unpack
#      char name[100];     // ASCII (+ Z unless filled)     a100/Z100
#      char mode[8];       // 0 padded, octal, null         a8  /A8
#      char uid[8];        // 0 padded, octal, null         a8  /A8
#      char gid[8];        // 0 padded, octal, null         a8  /A8
#      char size[12];      // 0 padded, octal, null         a12 /A12
#      char mtime[12];     // 0 padded, octal, null         a12 /A12
#      char checksum[8];   // 0 padded, octal, null, space  a8  /A8
#      char typeflag[1];   // see below                     a   /a
#      char linkname[100]; // ASCII + (Z unless filled)     a100/Z100
#      char magic[6];      // "ustar\0"                     a6  /A6
#      char version[2];    // "00"                          a2  /A2
#      char uname[32];     // ASCIIZ                        a32 /Z32
#      char gname[32];     // ASCIIZ                        a32 /Z32
#      char devmajor[8];   // 0 padded, octal, null         a8  /A8
#      char devminor[8];   // 0 padded, octal, null         a8  /A8
#      char prefix[155];   // ASCII (+ Z unless filled)     a155/Z155
#   };
#
# The #typeflag is one of several known values.
#
# POSIX indicates that "A POSIX-compliant implementation must treat any
# unrecognized typeflag value as a regular file."
#
# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:39
class Archive::Tar::Minitar::PosixHeader
  include ::Archive::Tar::Minitar::ByteSize

  # Creates a new PosixHeader. A PosixHeader cannot be created unless
  # +name+, +size+, +prefix+, and +mode+ are provided.
  #
  # @return [PosixHeader] a new instance of PosixHeader
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:135
  def initialize(v); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def checksum; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def devmajor; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def devminor; end

  # Indicates if the header was an empty header.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:154
  def empty?; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def gid; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def gname; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def linkname; end

  # Returns +true+ if the header is a long name special header which indicates
  # that the next block of data is the filename.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:165
  def long_name?; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def magic; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def mode; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def mtime; end

  # The name of the file. By default, limited to 100 bytes. Required. May be
  # longer (up to BLOCK_SIZE bytes) if using the GNU long name tar extension.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:62
  def name; end

  # The name of the file. By default, limited to 100 bytes. Required. May be
  # longer (up to BLOCK_SIZE bytes) if using the GNU long name tar extension.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:62
  def name=(_arg0); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def prefix; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def size; end

  # A string representation of the header.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:170
  def to_s; end

  # A string representation of the header.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:170
  def to_str; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def typeflag; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def uid; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def uname; end

  # Update the checksum field.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:177
  def update_checksum; end

  # Indicates if the header has a valid magic value.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:159
  def valid?; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:57
  def version; end

  private

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:194
  def calculate_checksum(hdr); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:198
  def header(chksum); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:186
  def oct(num, len); end

  class << self
    # Creates a new PosixHeader from a BLOCK_SIZE-byte data buffer.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:83
    def from_data(data); end

    # Creates a new PosixHeader from a data stream.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:71
    def from_stream(stream); end

    # Creates a new PosixHeader from a data stream. Deprecated; use
    # PosixHeader.from_stream instead.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:77
    def new_from_stream(stream); end

    private

    # @raise [ArgumentError]
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:127
    def strict_oct(string); end
  end
end

# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:40
Archive::Tar::Minitar::PosixHeader::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# All fields available in a POSIX tar(1) header.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:54
Archive::Tar::Minitar::PosixHeader::FIELDS = T.let(T.unsafe(nil), Array)

# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:43
Archive::Tar::Minitar::PosixHeader::GNU_EXT_LONG_LINK = T.let(T.unsafe(nil), String)

# The pack format passed to Array#pack for encoding a header.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:65
Archive::Tar::Minitar::PosixHeader::HEADER_PACK_FORMAT = T.let(T.unsafe(nil), String)

# The unpack format passed to String#unpack for decoding a header.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:67
Archive::Tar::Minitar::PosixHeader::HEADER_UNPACK_FORMAT = T.let(T.unsafe(nil), String)

# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:41
Archive::Tar::Minitar::PosixHeader::MAGIC_BYTES = T.let(T.unsafe(nil), String)

# Fields that may be set in a POSIX tar(1) header.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:48
Archive::Tar::Minitar::PosixHeader::OPTIONAL_FIELDS = T.let(T.unsafe(nil), Array)

# Fields that must be set in a POSIX tar(1) header.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/posix_header.rb:46
Archive::Tar::Minitar::PosixHeader::REQUIRED_FIELDS = T.let(T.unsafe(nil), Array)

# The class that reads a tar format archive from a data stream. The data
# stream may be sequential or random access, but certain features only work
# with random access data streams.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:7
class Archive::Tar::Minitar::Reader
  include ::Enumerable
  include ::Archive::Tar::Minitar::ByteSize

  # Creates and returns a new Reader object.
  #
  # @return [Reader] a new instance of Reader
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:203
  def initialize(io); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:283
  def close; end

  # Returns false if the reader is open (it never closes).
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:279
  def closed?; end

  # Iterates through each entry in the data stream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:230
  def each; end

  # Iterates through each entry in the data stream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:230
  def each_entry; end

  # Resets the read pointer to the beginning of data stream. Do not call
  # this during a #each or #each_entry iteration. This only works with
  # random access data streams that respond to #rewind and #pos.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:215
  def rewind; end

  class << self
    # Iterates over each entry in the provided input. This wraps the common
    # pattern of:
    #
    #     Archive::Tar::Minitar::Input.open(io) do |i|
    #       inp.each do |entry|
    #         # ...
    #       end
    #     end
    #
    # If a block is not provided, an enumerator will be created with the same
    # behaviour.
    #
    # call-seq:
    #    Archive::Tar::Minitar::Reader.each_entry(io) -> enumerator
    #    Archive::Tar::Minitar::Reader.each_entry(io) { |entry| block } -> obj
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:192
    def each_entry(io); end

    # With no associated block, +Reader::open+ is a synonym for
    # +Reader::new+. If the optional code block is given, it will be passed
    # the new _writer_ as an argument and the Reader object will
    # automatically be closed when the block terminates. In this instance,
    # +Reader::open+ returns the value of the block.
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:164
    def open(io); end
  end
end

# EntryStreams are pseudo-streams on top of the main data stream.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:32
class Archive::Tar::Minitar::Reader::EntryStream
  include ::Archive::Tar::Minitar::ByteSize

  # @return [EntryStream] a new instance of EntryStream
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:39
  def initialize(header, io); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:129
  def bytes_read; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def checksum; end

  # Closes the entry.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:148
  def close; end

  # Returns false if the entry stream is valid.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:143
  def closed?; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def devmajor; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def devminor; end

  # Returns +true+ if the entry represents a directory.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:87
  def directory; end

  # Returns +true+ if the entry represents a directory.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:87
  def directory?; end

  # Returns +true+ if the current read pointer is at the end of the
  # EntryStream data.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:111
  def eof?; end

  # Returns +true+ if the entry represents a plain file.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:104
  def file; end

  # Returns +true+ if the entry represents a plain file.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:104
  def file?; end

  # Returns the full and proper name of the entry.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:134
  def full_name; end

  # Reads one byte from the entry. Returns +nil+ if there is no more data
  # to read.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:79
  def getc; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def gid; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def gname; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def linkname; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def magic; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def mode; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def mtime; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def name; end

  # Returns the current read pointer in the EntryStream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:116
  def pos; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def prefix; end

  # Reads +len+ bytes (or all remaining data) from the entry. Returns
  # +nil+ if there is no more data to read.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:68
  def read(len = T.unsafe(nil)); end

  # Sets the current read pointer to the beginning of the EntryStream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:121
  def rewind; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def size; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def typeflag; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def uid; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def uname; end

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:36
  def version; end

  private

  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:154
  def invalidate; end
end

# This marks the EntryStream closed for reading without closing the
# actual data stream.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:13
module Archive::Tar::Minitar::Reader::InvalidEntryStream
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:26
  def closed?; end

  # @raise [ClosedStream]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:18
  def getc; end

  # @raise [ClosedStream]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:14
  def read(*_arg0); end

  # @raise [ClosedStream]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/reader.rb:22
  def rewind; end
end

# The exception raised when a file contains a relative path in secure mode
# (the default for this version).
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:94
class Archive::Tar::Minitar::SecureRelativePathError < ::Archive::Tar::Minitar::Error; end

# The exception raised when a data stream ends before the amount of data
# expected in the archive's PosixHeader.
#
# source://minitar-0.12.1/lib/archive/tar/minitar.rb:91
class Archive::Tar::Minitar::UnexpectedEOF < ::StandardError; end

# source://minitar-0.12.1/lib/archive/tar/minitar.rb:77
Archive::Tar::Minitar::VERSION = T.let(T.unsafe(nil), String)

# The class that writes a tar format archive to a data stream.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:5
class Archive::Tar::Minitar::Writer
  include ::Archive::Tar::Minitar::ByteSize

  # Creates and returns a new Writer object.
  #
  # @return [Writer] a new instance of Writer
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:103
  def initialize(io); end

  # Adds a file to the archive as +name+. The data can be provided in the
  # <tt>opts[:data]</tt> or provided to a yielded +WriteOnlyStream+. The
  # size of the file will be determined from the amount of data written
  # to the stream.
  #
  # Valid parameters to +opts+ are:
  #
  # <tt>:mode</tt>::  The Unix file permissions mode value. If not
  #                   provided, defaults to 0644.
  # <tt>:uid</tt>::   The Unix file owner user ID number.
  # <tt>:gid</tt>::   The Unix file owner group ID number.
  # <tt>:mtime</tt>:: File modification time, interpreted as an integer.
  # <tt>:data</tt>::  Optional. The data to write to the archive.
  #
  # If <tt>opts[:data]</tt> is provided, this acts the same as
  # #add_file_simple. Otherwise, the file's size will be determined from
  # the amount of data written to the stream.
  #
  # For #add_file to be used without <tt>opts[:data]</tt>, the Writer
  # must be wrapping a stream object that is seekable. Otherwise,
  # #add_file_simple must be used.
  #
  # +opts+ may be modified during the writing of the file to the stream.
  #
  # @raise [ClosedStream]
  # @yield [WriteOnlyStream.new(@io), opts]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:206
  def add_file(name, opts = T.unsafe(nil), &block); end

  # Adds a file to the archive as +name+. The data can be provided in the
  # <tt>opts[:data]</tt> or provided to a BoundedWriteStream that is
  # yielded to the provided block.
  #
  # If <tt>opts[:data]</tt> is provided, all other values to +opts+ are
  # optional. If the data is provided to the yielded BoundedWriteStream,
  # <tt>opts[:size]</tt> must be provided.
  #
  # Valid parameters to +opts+ are:
  #
  # <tt>:data</tt>::  Optional. The data to write to the archive.
  # <tt>:mode</tt>::  The Unix file permissions mode value. If not
  #                   provided, defaults to 0644.
  # <tt>:size</tt>::  The size, in bytes. If <tt>:data</tt> is provided,
  #                   this parameter may be ignored (if it is less than
  #                   the size of the data provided) or used to add
  #                   padding (if it is greater than the size of the data
  #                   provided).
  # <tt>:uid</tt>::   The Unix file owner user ID number.
  # <tt>:gid</tt>::   The Unix file owner group ID number.
  # <tt>:mtime</tt>:: File modification time, interpreted as an integer.
  #
  # An exception will be raised if the Writer is already closed, or if
  # more data is written to the BoundedWriteStream than expected.
  #
  # call-seq:
  #    writer.add_file_simple('foo.txt', :data => "bar")
  #    writer.add_file_simple('foo.txt', :size => 3) do |w|
  #      w.write("bar")
  #    end
  #
  # @raise [ClosedStream]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:138
  def add_file_simple(name, opts = T.unsafe(nil)); end

  # Closes the Writer. This does not close the underlying wrapped output
  # stream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:297
  def close; end

  # Returns false if the writer is open.
  #
  # @return [Boolean]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:291
  def closed?; end

  # Passes the #flush method to the wrapped stream, used for buffered
  # streams.
  #
  # @raise [ClosedStream]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:285
  def flush; end

  # Creates a directory entry in the tar.
  #
  # @raise [ClosedStream]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:243
  def mkdir(name, opts = T.unsafe(nil)); end

  # Creates a symbolic link entry in the tar.
  #
  # @raise [ClosedStream]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:262
  def symlink(name, link_target, opts = T.unsafe(nil)); end

  private

  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:323
  def split_name(name); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:305
  def write_header(header, long_name, short_name, prefix, needs_long_name); end

  class << self
    # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:65
    def const_missing(c); end

    # With no associated block, +Writer::open+ is a synonym for +Writer::new+.
    # If the optional code block is given, it will be passed the new _writer_
    # as an argument and the Writer object will automatically be closed when
    # the block terminates. In this instance, +Writer::open+ returns the value
    # of the block.
    #
    # call-seq:
    #    w = Archive::Tar::Minitar::Writer.open(STDOUT)
    #    w.add_file_simple('foo.txt', :size => 3)
    #    w.close
    #
    #    Archive::Tar::Minitar::Writer.open(STDOUT) do |w|
    #      w.add_file_simple('foo.txt', :size => 3)
    #    end
    #
    # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:89
    def open(io); end
  end
end

# A WriteOnlyStream that also has a size limit.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:27
class Archive::Tar::Minitar::Writer::BoundedWriteStream < ::Archive::Tar::Minitar::Writer::WriteOnlyStream
  include ::Archive::Tar::Minitar::ByteSize

  # @return [BoundedWriteStream] a new instance of BoundedWriteStream
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:48
  def initialize(io, limit); end

  # The maximum number of bytes that may be written to this data
  # stream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:44
  def limit; end

  # @raise [WriteBoundaryOverflow]
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:54
  def write(data); end

  # The current total number of bytes written to this data stream.
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:46
  def written; end

  class << self
    # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:30
    def const_missing(c); end
  end
end

# The exception raised when the user attempts to write more data to a
# BoundedWriteStream than has been allocated.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:10
class Archive::Tar::Minitar::Writer::WriteBoundaryOverflow < ::StandardError; end

# A stream wrapper that can only be written to. Any attempt to read
# from this restricted stream will result in a NameError being thrown.
#
# source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:14
class Archive::Tar::Minitar::Writer::WriteOnlyStream
  # @return [WriteOnlyStream] a new instance of WriteOnlyStream
  #
  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:15
  def initialize(io); end

  # source://minitar-0.12.1/lib/archive/tar/minitar/writer.rb:19
  def write(data); end
end

# source://minitar-0.12.1/lib/minitar.rb:11
Minitar = Archive::Tar::Minitar
